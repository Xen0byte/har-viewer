/* global HttpArchive */

import { uuidv4 } from "../helpers";

/**
 * @typedef {(object)} PostmanRequestBody
 * @property {string} mode - Postman stores the type of data associated with this request in this field.
 * @property {object[]} [urlencoded] - URL encoded parameters.
 * @property {object[]} [formdata] - Form data parameters.
 * @property {string} [raw] - Raw request body.
 */

/**
 * Create a postman item from har entry.
 *
 * @param {HttpArchive.Entry} entry - The har entry.
 * @returns {object} A postman item.
 */
function itemFromEntry(entry) {
  const id = uuidv4();

  /** @type {PostmanRequestBody} */
  let body = null;

  if (entry.request.postData) {
    let mode = null;

    switch (entry.request.postData.mimeType) {
      case "application/x-www-form-urlencoded":
        mode = "urlencoded";
        break;
      case "application/octet-stream":
        mode = "file";
        break;
      case "multipart/form-data":
        mode = "formdata";
        break;
      case "application/graphql":
      case "application/graphql+json":
        mode = "graphql"; // not official
        break;
      default:
        mode = "raw";
        break;
    }

    body = { mode };

    if (mode === "urlencoded" && entry.request.params) {
      body.urlencoded = entry.request.postData.params
        .map(p => ({
          key: p.name,
          value: p.value,
        }));
    } else if (mode === "formdata" && entry.request.params) {
      body.formdata = entry.request.postData.params
        .map(p => ({
          key: p.name,
          value: p.value,
        }));
    } else if (entry.request.postData.text) {
      body.raw = entry.request.postData.text;
    }
  }

  return {
    id,
    name: entry.request.url.split("?")[0],
    description: entry.response.status === 0 ? "Blocked" : null,
    request: {
      url: entry.request.url,
      method: entry.request.method.toUpperCase(),
      header: entry.request.headers
        .map(h => ({
          key: h.name,
          value: h.value,
        })),
      body,
    },
    response: [{
      id: uuidv4(),
      originalRequest: id,
      responseTime: entry.time,
      header: entry.response.headers
        .map(h => ({
          key: h.name,
          value: h.value,
        })),
      body: entry.response.content.text,
      status: `${entry.response.status} ${entry.response.statusText}`,
      code: entry.response.status,
    }],
  };
}

/**
 * Generate a postman v2.x file.
 *
 * @param {string} collectionName - The name of the collection.
 * @param {HttpArchive} data - The data to serialize.
 * @returns {string} A postman v2.x file as json string.
 */
function generatePostman(collectionName, data) {
  const item = [];

  for (let i = 0; i < data.log.entries.length; i++) {
    const entry = itemFromEntry(data.log.entries[i]);
    item.push(entry);
  }

  const postmanData = {
    info: {
      name: collectionName,
      schema: "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
      description: "Generated by HTTP Archive Viewer",
      _postman_id: uuidv4(),
    },
    item,
  };

  return JSON.stringify(postmanData);
}

export default generatePostman;
