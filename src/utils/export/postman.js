/**
 * Generate a rfc4122 compliant v4 uuid.
 *
 * @returns {string} A rfc4122 compliant v4 uuid.
 */
 function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => {
    // eslint-disable-next-line no-bitwise
    const r = Math.random() * 16 | 0;
    // eslint-disable-next-line no-mixed-operators,no-bitwise
    return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
  });
}

/**
 * Create a postman item from har entry.
 *
 * @param {HttpArchive.Entry} entry - The har entry.
 * @returns {object} A postman item.
 */
function itemFromEntry(entry) {
  const id = uuidv4();

  let body = null;

    if (entry.request.postData) {
      let mode = null;

      switch (entry.request.postData.mimeType) {
        case "application/x-www-form-urlencoded":
          mode = "urlencoded";
          break;
        case "application/octet-stream":
          mode = "file";
          break;
        case "multipart/form-data":
          mode = "formdata";
          break;
        case "application/graphql":
        case "application/graphql+json":
          mode = "graphql"; // not official
          break;
        default:
          mode = "raw";
          break;
      }

      body = { mode };

      if (mode === "urlencoded" && entry.request.params) {
        body.urlencoded = entry.request.postData.params
          .map(p => ({
            key: p.name,
            value: p.value,
          }));
      } else if (mode === "formdata" && entry.request.params) {
        body.formdata = entry.request.postData.params
          .map(p => ({
            key: p.name,
            value: p.value,
          }));
      } else if (entry.request.postData.text) {
        body.raw = entry.request.postData.text;
      }
    }

  return {
    id,
    name: entry.request.url.split("?")[0],
    description: entry.response.status === 0 ? "Blocked" : null,
    request: {
      url: entry.request.url,
      method: entry.request.method.toUpperCase(),
      header: entry.request.headers
        .map(h => ({
          key: h.name,
          value: h.value,
        })),
      body,
    },
    response: [{
      id: uuidv4(),
      originalRequest: id,
      responseTime: entry.time,
      header: entry.response.headers
        .map(h => ({
          key: h.name,
          value: h.value,
        })),
      body: entry.response.content.text,
      status: `${entry.response.status} ${entry.response.statusText}`,
      code: entry.response.status,
    }],
  };
}

/**
 * Generate a postman v2.x file.
 *
 * @param {string} collectionName - The name of the collection.
 * @param {HttpArchive} data - The data to serialize.
 * @returns {string} A postman v2.x file as json string.
 */
function generatePostman(collectionName, data) {
  const item = [];

  for (let i = 0; i < data.log.entries.length; i++) {
    const entry = itemFromEntry(data.log.entries[i]);
    item.push(entry);
  }

  const data = {
    info: {
      name: collectionName,
      schema: "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
      description: "Generated by HTTP Archive Viewer",
      _postman_id: uuidv4(),
    },
    item,
  };

  return JSON.stringify(data);
}

export default generatePostman;
