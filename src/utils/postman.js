/* eslint-disable import/prefer-default-export */

/**
 * Generate a rfc4122 compliant v4 uuid.
 *
 * @returns {string} A rfc4122 compliant v4 uuid.
 */
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => {
    // eslint-disable-next-line no-bitwise
    const r = Math.random() * 16 | 0;
    // eslint-disable-next-line no-mixed-operators,no-bitwise
    return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
  });
}

/**
 * Generate a postman v2.x file.
 *
 * @param {string} name - The name of the collection.
 * @param {object} data - The data to serialize.
 * @param {string} version - The postman format version.
 * @returns {object} A postman v2.x file.
 */
function v2(name, data, version) {
  const collectionId = uuidv4();
  const item = [];

  for (let i = 0; i < data.log.entries.length; i++) {
    const entry = data.log.entries[i];
    const id = uuidv4();

    let body = null;

    if (entry.request.postData) {
      let mode = null;

      switch (entry.request.postData.mimeType) {
        case "application/x-www-form-urlencoded":
          mode = "urlencoded";
          break;
        case "application/octet-stream":
          mode = "file";
          break;
        case "multipart/form-data":
          mode = "formdata";
          break;
        case "application/graphql":
        case "application/graphql+json":
          mode = "graphql"; // not official
          break;
        default:
          mode = "raw";
          break;
      }

      body = { mode };

      if (mode === "urlencoded" && entry.request.params) {
        body.urlencoded = entry.request.postData.params
          .map(p => ({
            key: p.name,
            value: p.value,
          }));
      } else if (mode === "formdata" && entry.request.params) {
        body.formdata = entry.request.postData.params
          .map(p => ({
            key: p.name,
            value: p.value,
          }));
      } else if (entry.request.postData.text) {
        body.raw = entry.request.postData.text;
      }
    }

    item.push({
      id,
      name: entry.request.url.split("?")[0],
      description: entry.response.status === 0 ? "Blocked" : null,
      request: {
        url: entry.request.url,
        method: entry.request.method.toUpperCase(),
        header: entry.request.headers
          .map(h => ({
            key: h.name,
            value: h.value,
          })),
        body,
      },
      response: [{
        id: uuidv4(),
        originalRequest: id,
        responseTime: entry.time,
        header: entry.response.headers
          .map(h => ({
            key: h.name,
            value: h.value,
          })),
        body: entry.response.content.text,
        status: `${entry.response.status} ${entry.response.statusText}`,
        code: entry.response.status,
      }],
    });
  }

  return {
    info: {
      name,
      schema: `https://schema.getpostman.com/json/collection/v${version}/collection.json`,
      description: "Generated by HTTP Archive Viewer",
      _postman_id: collectionId,
    },
    item,
  };
}

// https://schema.postman.com/
export const postmanVersions = [
  "2.0.0",
  "2.1.0",
];

export const toPostman = (name, data, version) => {
  switch (version) {
    case "2.0.0":
    case "2.1.0":
      return v2(name, data, version);
    default:
      return null;
  }
};
